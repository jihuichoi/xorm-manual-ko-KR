### Join 사용법

#### Join(string,interface{},string)

첫번째 파라미터는 조인 유형으로 데이터베이스 유형에 따라 지원하는 조인 유형을 넣을 수 있습니다. 두번째 파라미터는 테이블명을 문자열 형식으로 넣거나 크기가 2인 `[]string{"tablename", "alias"}` 으로 넣을 수 있습니다. 세번째 파라미터는 조인 조건입니다.

아래는 예제로 설명한 사용법입니다.

예제에서는 다음과 같이 가정합니다. 두 개의 테이블(user, group)이 있습니다. 그리고 모든 user 는 1개의 group 에 속해 있습니다. 따라서 구조체는 다음과 같습니다.

```Go
type Group struct {
	Id int64
	Name string
}
```

```Go
type User struct {
	Id int64
	Name string
	GroupId int64 `xorm:"index"`
}
```

If we want to query all user and his's grpu name. how to do via xorm? The code is below:

```Go
type UserGroup struct {
    User `xorm:"extends"`
    Name string
}

func (UserGroup) TableName() string {
	return "user"
}

var users []UserGroup
err := engine.Join("INNER", "group", "group.id = user.group_id").Find(&users)
```

Here we composite `User` and string type as a new struct `UserGroup`. And we add a xorm tag `extends` on `User`. Of course, we can also use Sql function to query the data.

```Go
var users []UserGroup
err := engine.Sql("select user.*, group.name from user, group where user.group_id = group.id").Find(&users)
```

And then we find we also need Group's id because we will put a link on the web page. So we can change the `UserGroup`, now we composite two struct as a new struct. The code is below:

```Go
type UserGroup struct {
    User `xorm:"extends"`
    Group `xorm:"extends"`
}

func (UserGroup) TableName() string {
	return "user"
}

var users []UserGroup
err := engine.Join("INNER", "group", "group.id = user.group_id").Find(&users)
```

Notice the sequence of composite of `User` and `Group` because `User` has `Id` and `Grpup` has `Id` two. There is a rule we should obey:

The sequence of struct field SHOULD be the same as the sequence of select columns.

And another point should be noticed that if you use the composited struct on html template files. You maybe have to use `{{.User.Id}}` or `{{.Group.Id}}` but not `{{.Id}}`

And for more join tables it also ok.

```Go
type Type struct {
	Id int64
	Name string
}

type UserGroupType struct {
    User `xorm:"extends"`
    Group `xorm:"extends"`
    Type `xorm:"extends"`
}

var users []UserGroupType
engine.Table("user").Join("INNER", "group", "group.id = user.group_id").
	Join("INNER", "type", "type.id = user.type_id").
	Find(&users)
```

Of course , we could use `Where`, `And`, `Or` as condition, or use the second param of `Find` as condition.

```Go
engine.Table("user").Join("INNER", "group", "group.id = user.group_id").
	Join("INNER", "type", "type.id = user.type_id").
	Where("user.name like ?", "%"+name+"%").Find(&users, &User{Name:name})
```

Finally, we can use alias on the process. For example:

```Go
engine.Table("user").Alias("u").
	Join("INNER", []string{"group", "g"}, "g.id = u.group_id").
	Join("INNER", "type", "type.id = u.type_id").
	Where("u.name like ?", "%"+name+"%").Find(&users, &User{Name:name})
```
